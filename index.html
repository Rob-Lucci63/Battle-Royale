<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OnePiece Mini 3D — سوم شخص (گرافیک پایین)</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1020;color:#fff;font-family:Tahoma,Arial}
    #gameCanvas{display:block;width:100%;height:100vh}
    /* UI ساده برای موبایل */
    .ui {
      position: absolute; left: 8px; top: 8px; z-index: 20;
      background: rgba(0,0,0,0.35); padding:8px;border-radius:8px;
    }
    .hud {position:absolute; right:8px; top:8px; z-index:20; text-align:left}
    .btn {user-select:none; touch-action:none; font-weight:bold; padding:10px 12px; border-radius:8px; margin:6px; background:rgba(255,255,255,0.06); color:#fff}
    /* جوی‌استیک برای موبایل */
    #joystick {
      position: absolute; left: 20px; bottom: 120px; z-index: 21;
      width: 100px; height: 100px; background: rgba(255,255,255,0.1); border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      touch-action: none;
    }
    #joystick-knob {
      width: 40px; height: 40px; background: rgba(255,255,255,0.3); border-radius: 50%;
      touch-action: none;
    }
    /* کنترل حمله پایین */
    .attack-pad{position:absolute; right:20px; bottom:120px; z-index:21; display:flex;flex-direction:column; gap:8px}
    .attack-pad .btn{width:80px; height:50px; font-size:14px;}
    /* کنترل چرخش دوربین */
    .camera-controls {
      position: absolute; left: 50%; bottom: 20px; z-index: 21;
      transform: translateX(-50%); display: flex; gap: 10px;
    }
    .camera-btn {
      width: 50px; height: 50px; border-radius: 50%; background: rgba(255,255,255,0.1);
      display: flex; align-items: center; justify-content: center; font-size: 18px;
    }
    .label{font-size:13px; opacity:0.9}
    .info {font-size:14px}
    /* راهنما کیبورد */
    .keyboard-help{position:absolute; left:8px; bottom:8px; z-index:20; background:rgba(0,0,0,0.35); padding:8px;border-radius:8px; display:none;} /* مخفی برای موبایل */
    @media (min-width: 768px) {.keyboard-help{display:block;}}
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div class="hud">
    <div class="ui">
      <div class="label">قلب‌ها: <span id="hp">100</span></div>
      <div class="label">امتیاز: <span id="score">0</span></div>
      <div class="label">High: <span id="high">0</span></div>
    </div>
  </div>
  <!-- جوی‌استیک -->
  <div id="joystick">
    <div id="joystick-knob"></div>
  </div>
  <!-- دکمه‌های حمله -->
  <div class="attack-pad">
    <div class="btn" id="attackL">لوفی</div>
    <div class="btn" id="attackC">کاکو</div>
  </div>
  <!-- کنترل‌های چرخش دوربین -->
  <div class="camera-controls">
    <div class="camera-btn" id="camLeft">←</div>
    <div class="camera-btn" id="camRight">→</div>
  </div>
  <div class="keyboard-help">WASD یا ←↑→↓ حرکت — J حمله لوفی — K حمله کاکو — Mouse drag برای چرخش دوربین</div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script>
    // بازی سوم شخص ساده — گرافیک پایین، بهینه برای موبایل
    const canvas = document.getElementById('gameCanvas');
    const renderer = new THREE.WebGLRenderer({canvas, antialias:false});
    renderer.setPixelRatio(window.devicePixelRatio ? Math.min(window.devicePixelRatio, 1.2) : 1); // کاهش برای سرعت بیشتر
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = false;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a1320);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 200);

    // زمین
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(120, 120, 1,1),
      new THREE.MeshBasicMaterial({color:0x116622})
    );
    ground.rotation.x = -Math.PI/2; scene.add(ground);

    // تابعی برای ساخت humanoid ساده
    function makeHumanoid(color){
      const g = new THREE.Group();
      const body = new THREE.Mesh(new THREE.BoxGeometry(0.9,1.2,0.5), new THREE.MeshBasicMaterial({color}));
      const head = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,0.6), new THREE.MeshBasicMaterial({color:0xffffff}));
      head.position.y = 1.05;
      body.position.y = 0.2;
      const lArm = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.6,0.2), new THREE.MeshBasicMaterial({color}));
      const rArm = lArm.clone();
      lArm.position.set(-0.6,0.2,0); rArm.position.set(0.6,0.2,0);
      const lLeg = new THREE.Mesh(new THREE.BoxGeometry(0.25,0.7,0.25), new THREE.MeshBasicMaterial({color}));
      const rLeg = lLeg.clone();
      lLeg.position.set(-0.22,-0.7,0); rLeg.position.set(0.22,-0.7,0);
      g.add(body, head, lArm, rArm, lLeg, rLeg);
      return g;
    }

    const player = makeHumanoid(0xff5555);
    player.position.set(0,0.7,0);
    scene.add(player);

    // تنظیمات دوربین سوم شخص: افست قابل چرخش
    let camDistance = 7;
    let camHeight = 4;
    let camAngle = 0;
    const camOffset = new THREE.Vector3(0, camHeight, camDistance);

    // دشمن‌ها
    const enemies = [];
    function spawnEnemy(pos){
      const e = makeHumanoid(0x5588ff);
      e.position.copy(pos);
      e.health = 30;
      e.speed = 0.035 + Math.random()*0.015; // افزایش سرعت دشمن
      e.lastHitTime = 0;
      e.normalSpeed = e.speed; // برای restore بعد slow
      scene.add(e);
      enemies.push(e);
    }

    // میوه‌ها
    const fruits = [];
    function makeFruit(type, pos){
      const color = type==='luffy' ? 0xff4444 : 0xffd266;
      const s = new THREE.Mesh(new THREE.SphereGeometry(0.35,8,6), new THREE.MeshBasicMaterial({color}));
      s.position.copy(pos);
      s.type = type;
      s.userData = { collected: false };
      scene.add(s);
      fruits.push(s);
    }

    // پرتابه‌ها
    const projectiles = [];

    function spawnLuffyAttack(origin, dir){
      const p = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.4,1.8), new THREE.MeshBasicMaterial({color:0xff6666}));
      p.position.copy(origin);
      p.dir = dir.clone().normalize();
      p.speed = 0.8; // کمی سریع‌تر
      p.type = 'luffy';
      scene.add(p);
      projectiles.push(p);
    }

    function spawnCacoAttack(origin, dir){
      const p = new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.18,1.6,6), new THREE.MeshBasicMaterial({color:0xffd266}));
      p.rotation.x = Math.PI/2;
      p.position.copy(origin);
      p.dir = dir.clone().normalize();
      p.speed = 0.7; // کمی سریع‌تر
      p.type = 'caco';
      p.life = 0;
      scene.add(p);
      projectiles.push(p);
    }

    // ورودی‌ها
    const input = {left:0, right:0, up:0, down:0, attackL:false, attackC:false};
    let attackCooldown = 0;

    // فلگ‌های چرخش دوربین
    let camLeftPressed = false;
    let camRightPressed = false;

    // بایند دکمه‌های حمله
    function bindBtn(id, keyName){
      const el = document.getElementById(id);
      let pressed = false;
      el.addEventListener('touchstart', (e)=>{ e.preventDefault(); pressed=true; input[keyName]=true; });
      el.addEventListener('touchend', (e)=>{ e.preventDefault(); pressed=false; input[keyName]=false; });
      el.addEventListener('mousedown', (e)=>{ e.preventDefault(); pressed=true; input[keyName]=true; });
      el.addEventListener('mouseup', (e)=>{ e.preventDefault(); pressed=false; input[keyName]=false; });
    }
    bindBtn('attackL','attackL');
    bindBtn('attackC','attackC');

    // بایند دکمه‌های دوربین (بهبود: فلگ global)
    function bindCamBtn(id, isLeft){
      const el = document.getElementById(id);
      el.addEventListener('touchstart', (e)=>{ e.preventDefault(); if(isLeft) camLeftPressed=true; else camRightPressed=true; });
      el.addEventListener('touchend', (e)=>{ e.preventDefault(); if(isLeft) camLeftPressed=false; else camRightPressed=false; });
      el.addEventListener('mousedown', (e)=>{ e.preventDefault(); if(isLeft) camLeftPressed=true; else camRightPressed=true; });
      el.addEventListener('mouseup', (e)=>{ e.preventDefault(); if(isLeft) camLeftPressed=false; else camRightPressed=false; });
    }
    bindCamBtn('camLeft', true);
    bindCamBtn('camRight', false);

    // کیبورد
    window.addEventListener('keydown', (e)=>{
      if(e.key==='a' || e.key==='ArrowLeft') input.left = 1;
      if(e.key==='d' || e.key==='ArrowRight') input.right = 1;
      if(e.key==='w' || e.key==='ArrowUp') input.up = 1;
      if(e.key==='s' || e.key==='ArrowDown') input.down = 1;
      if(e.key==='j') input.attackL = true;
      if(e.key==='k') input.attackC = true;
    });
    window.addEventListener('keyup', (e)=>{
      if(e.key==='a' || e.key==='ArrowLeft') input.left = 0;
      if(e.key==='d' || e.key==='ArrowRight') input.right = 0;
      if(e.key==='w' || e.key==='ArrowUp') input.up = 0;
      if(e.key==='s' || e.key==='ArrowDown') input.down = 0;
      if(e.key==='j') input.attackL = false;
      if(e.key==='k') input.attackC = false;
    });

    // جوی‌استیک
    const joystick = document.getElementById('joystick');
    const knob = document.getElementById('joystick-knob');
    let joystickActive = false;
    let joystickCenter = {x: 0, y: 0};
    let joystickVector = {x: 0, y: 0};

    joystick.addEventListener('touchstart', (e) => {
      e.preventDefault();
      joystickActive = true;
      const touch = e.touches[0];
      const rect = joystick.getBoundingClientRect();
      joystickCenter.x = rect.left + rect.width / 2;
      joystickCenter.y = rect.top + rect.height / 2;
      updateJoystick(touch.clientX, touch.clientY);
    });

    joystick.addEventListener('touchmove', (e) => {
      if (!joystickActive) return;
      e.preventDefault();
      const touch = e.touches[0];
      updateJoystick(touch.clientX, touch.clientY);
    });

    joystick.addEventListener('touchend', (e) => {
      e.preventDefault();
      joystickActive = false;
      joystickVector = {x: 0, y: 0};
      knob.style.transform = 'translate(0, 0)';
      input.left = 0; input.right = 0; input.up = 0; input.down = 0;
    });

    function updateJoystick(clientX, clientY) {
      const dx = clientX - joystickCenter.x;
      const dy = clientY - joystickCenter.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const maxDist = 35; // کمی افزایش برای حساسیت بهتر
      if (dist > maxDist) {
        const normX = dx / dist;
        const normY = dy / dist;
        joystickVector.x = normX * maxDist;
        joystickVector.y = normY * maxDist;
      } else {
        joystickVector.x = dx;
        joystickVector.y = dy;
      }
      knob.style.transform = `translate(${joystickVector.x}px, ${joystickVector.y}px)`;
      // ورودی با threshold بیشتر برای جلوگیری از حساسیت کم
      input.left = joystickVector.x < -15 ? 1 : 0;
      input.right = joystickVector.x > 15 ? 1 : 0;
      input.up = joystickVector.y < -15 ? 1 : 0; // y منفی برای حرکت جلو (up)
      input.down = joystickVector.y > 15 ? 1 : 0;
    }

    // Mouse drag برای دسکتاپ
    let mouseDown = false;
    let lastMouseX = 0;
    canvas.addEventListener('mousedown', (e) => {
      mouseDown = true;
      lastMouseX = e.clientX;
    });
    canvas.addEventListener('mousemove', (e) => {
      if (!mouseDown) return;
      const deltaX = e.clientX - lastMouseX;
      camAngle += deltaX * 0.005; // حساسیت کمتر برای کنترل بهتر
      lastMouseX = e.clientX;
    });
    canvas.addEventListener('mouseup', () => { mouseDown = false; });
    canvas.addEventListener('mouseleave', () => { mouseDown = false; });

    // ویژگی‌های بازیکن
    let playerHP = 100; let score = 0;
    const hpEl = document.getElementById('hp');
    const scEl = document.getElementById('score');
    const highEl = document.getElementById('high');
    let high = parseInt(localStorage.getItem('onepiece_high') || 0);
    highEl.textContent = high;

    // بروزرسانی بازیکن
    const velocity = new THREE.Vector3();
    function updatePlayer(dt){
      const speed = 5.0; // افزایش سرعت حرکت
      let move = new THREE.Vector3();
      if(input.left) move.x -= 1;
      if(input.right) move.x += 1;
      if(input.up) move.z -= 1;
      if(input.down) move.z += 1;
      if(move.length() > 0){
        move.normalize();
        velocity.x = move.x * speed;
        velocity.z = move.z * speed;
      } else {
        velocity.x = THREE.MathUtils.lerp(velocity.x, 0, 0.3); // سریع‌تر توقف
        velocity.z = THREE.MathUtils.lerp(velocity.z, 0, 0.3);
      }

      player.position.x += velocity.x * dt;
      player.position.z += velocity.z * dt;

      // چرخش بازیکن
      if(move.length() > 0){
        const angle = Math.atan2(move.x, -move.z);
        player.rotation.y = THREE.MathUtils.lerpAngle(player.rotation.y, angle, 0.25); // سریع‌تر چرخش
      }

      // بروزرسانی دوربین
      if(camLeftPressed) camAngle -= 1.5 * dt; // سرعت چرخش مناسب (1.5 rad/sec)
      if(camRightPressed) camAngle += 1.5 * dt;
      const camPos = new THREE.Vector3(0, camHeight, camDistance);
      camPos.applyAxisAngle(new THREE.Vector3(0, 1, 0), camAngle);
      const desired = player.position.clone().add(camPos);
      camera.position.lerp(desired, 0.15); // کمی سریع‌تر follow
      camera.lookAt(player.position.x, player.position.y + 0.8, player.position.z);

      // حملات
      attackCooldown -= dt;
      if(input.attackL && attackCooldown <= 0){
        input.attackL = false;
        attackCooldown = 0.4; // کول‌داون کمتر
        const front = new THREE.Vector3(0, 0.8, -1).applyQuaternion(player.quaternion).add(player.position);
        const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion);
        spawnLuffyAttack(front, dir);
      }
      if(input.attackC && attackCooldown <= 0){
        input.attackC = false;
        attackCooldown = 0.4;
        const front = new THREE.Vector3(0, 0.8, -1).applyQuaternion(player.quaternion).add(player.position);
        const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion);
        spawnCacoAttack(front, dir);
      }
    }

    // بروزرسانی دشمن‌ها
    function updateEnemies(dt){
      const now = performance.now() / 1000;
      for(let i = enemies.length - 1; i >= 0; i--){
        const e = enemies[i];
        const dir = player.position.clone().sub(e.position);
        const dist = dir.length();
        if(dist > 0.2){
          dir.normalize();
          let currentSpeed = e.normalSpeed;
          if(e.slowUntil && now < e.slowUntil) {
            currentSpeed *= 0.6;
          } else if(e.slowUntil) {
            e.speed = e.normalSpeed; // restore
            delete e.slowUntil;
          }
          e.position.add(dir.multiplyScalar(currentSpeed * dt));
        }
        // برخورد
        if(e.position.distanceTo(player.position) < 0.9 && now - e.lastHitTime > 1){
          playerHP -= 10;
          e.lastHitTime = now;
          if(playerHP <= 0){
            playerHP = 0;
            gameOver();
          }
        }
        if(e.health <= 0){
          scene.remove(e);
          enemies.splice(i, 1);
          score += 10;
          updateHUD();
        }
      }
    }

    function updateProjectiles(dt){
      for(let i = projectiles.length - 1; i >= 0; i--){
        const p = projectiles[i];
        const move = p.dir.clone().multiplyScalar(p.speed * dt);
        p.position.add(move);
        if(p.type === 'caco'){
          p.life += dt * 8; // تنظیم arc
          p.position.y = Math.max(0.35, 0.5 + Math.sin(p.life) * 0.8);
        }
        // برخورد
        for(let j = enemies.length - 1; j >= 0; j--){
          const e = enemies[j];
          if(e.position.distanceTo(p.position) < 1.1){
            if(p.type === 'luffy'){
              e.health -= 20;
              const knock = e.position.clone().sub(player.position).normalize().multiplyScalar(1.6);
              e.position.add(knock);
            } else if(p.type === 'caco'){
              e.health -= 14;
              e.slowUntil = performance.now() / 1000 + 2; // slow با زمان
            }
            scene.remove(p);
            projectiles.splice(i, 1);
            break;
          }
        }
        if(p.position.distanceTo(player.position) > 40){
          scene.remove(p);
          projectiles.splice(i, 1);
        }
      }
    }

    function updateFruits(){
      for(let i = fruits.length - 1; i >= 0; i--){
        const f = fruits[i];
        if(!f.userData.collected && f.position.distanceTo(player.position) < 1.1){
          f.userData.collected = true;
          score += 6;
          scene.remove(f);
          fruits.splice(i, 1);
          updateHUD();
        }
      }
    }

    function updateHUD(){
      hpEl.textContent = Math.max(0, Math.floor(playerHP));
      scEl.textContent = score;
      if(score > high){
        high = score;
        localStorage.setItem('onepiece_high', high);
        highEl.textContent = high;
      }
    }

    let lastSpawn = 0; let prevTime = 0;
    function gameLoop(currentTime){
      const dt = Math.min(1/30, (currentTime - prevTime) / 1000); // cap بالاتر برای سرعت
      prevTime = currentTime;

      updatePlayer(dt);
      updateEnemies(dt);
      updateProjectiles(dt);
      updateFruits();
      updateHUD();

      // اسپاون
      lastSpawn += dt;
      if(lastSpawn > 1.8){ // کمی سریع‌تر اسپاون
        lastSpawn = 0;
        if(Math.random() < 0.65){
          const x = (Math.random() - 0.5) * 40;
          const z = (Math.random() - 0.5) * 40;
          spawnEnemy(new THREE.Vector3(x, 0.7, z));
        } else {
          const x = (Math.random() - 0.5) * 20;
          const z = (Math.random() - 0.5) * 20;
          const type = Math.random() < 0.5 ? 'luffy' : 'caco';
          makeFruit(type, new THREE.Vector3(x, 0.35, z));
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(gameLoop);
    }

    function gameOver(){
      alert('تمام شد! امتیاز: ' + score + ' — بازی دوباره شروع کنید');
      if(score > high){
        localStorage.setItem('onepiece_high', score);
      }
      location.reload();
    }

    // شروع
    for(let i = 0; i < 2; i++){
      spawnEnemy(new THREE.Vector3((Math.random() - 0.5) * 12, 0.7, (Math.random() - 0.5) * 12));
    }
    makeFruit('luffy', new THREE.Vector3(3, 0.35, 3));
    makeFruit('caco', new THREE.Vector3(-3, 0.35, 3));

    // ریسایز
    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    // موقعیت اولیه
    const initialCamPos = player.position.clone().add(camOffset);
    camera.position.copy(initialCamPos);
    camera.lookAt(player.position);
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>